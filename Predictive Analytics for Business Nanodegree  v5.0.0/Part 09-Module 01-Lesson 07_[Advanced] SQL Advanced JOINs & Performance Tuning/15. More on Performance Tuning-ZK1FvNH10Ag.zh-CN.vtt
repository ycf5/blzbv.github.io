WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.220
数据库是运行在电脑上的一款软件

00:00:03.220 --> 00:00:06.595
和所有软件一样 它也有局限性

00:00:06.594 --> 00:00:11.234
它只能在硬件处理性能范围内处理信息

00:00:11.234 --> 00:00:13.154
提升查询运行速度的一个办法

00:00:13.154 --> 00:00:16.320
是减少需要进行的计算的数量

00:00:16.320 --> 00:00:22.435
为此 你需要了解一点 SQL 实际如何进行这些计算

00:00:22.434 --> 00:00:24.209
首先 我们来了解一下哪些主要因素

00:00:24.210 --> 00:00:25.949
将影响一项给定的查询

00:00:25.949 --> 00:00:29.195
需要进行的计算的数量

00:00:29.195 --> 00:00:32.344
毋庸置疑 表格大小是重要因素

00:00:32.344 --> 00:00:36.385
如果查询设计包含几百万列甚至更多

00:00:36.386 --> 00:00:38.330
这将会影响性能

00:00:38.329 --> 00:00:40.939
如果查询需要合并两张表格

00:00:40.939 --> 00:00:44.170
会大大增加结果集的列数

00:00:44.170 --> 00:00:46.320
查询将可能变慢

00:00:46.320 --> 00:00:51.000
最后 聚合会很大程度上影响查询运行时间

00:00:51.000 --> 00:00:53.380
合并若干列产生

00:00:53.380 --> 00:00:58.030
一项结果比单纯查询这些列需要进行更多的计算

00:00:58.030 --> 00:01:02.605
尤其是 去重以后再计数相比常规计数要花费更多时间

00:01:02.604 --> 00:01:07.534
因为它需要检查对所有列进行交叉验证以获得重复值

00:01:07.534 --> 00:01:10.239
查询运行时间也依赖于不受你控制的且与

00:01:10.239 --> 00:01:14.209
数据库本身有关的一些因素

00:01:14.209 --> 00:01:16.734
数据库要同时运行的查询越多

00:01:16.734 --> 00:01:19.299
数据库就要在指定时间内处理的数据越多

00:01:19.299 --> 00:01:21.254
所有运行就会越慢

00:01:21.254 --> 00:01:23.750
更坏的情况是 其他人在运行

00:01:23.750 --> 00:01:25.775
尤其是资源密集型查询

00:01:25.775 --> 00:01:28.790
而这些查询符合我们提到的标准

00:01:28.790 --> 00:01:33.430
同时 不同数据库在执行给定任务时表现不同

00:01:33.430 --> 00:01:37.590
例如 Postgres 在快速读写新列方面有优势

00:01:37.590 --> 00:01:41.750
而 Redshift 在执行快速聚合方面表现更好 

00:01:41.750 --> 00:01:44.885
这些就是你很可能无法控制的因素 但是

00:01:44.885 --> 00:01:46.609
如果你了解你正在使用的系统

00:01:46.609 --> 00:01:50.329
你可以在系统性能范围内更高效地执行查询

00:01:50.329 --> 00:01:52.219
我们暂且忽略不受控制的因素

00:01:52.219 --> 00:01:55.000
而关注我们可以控制的因素


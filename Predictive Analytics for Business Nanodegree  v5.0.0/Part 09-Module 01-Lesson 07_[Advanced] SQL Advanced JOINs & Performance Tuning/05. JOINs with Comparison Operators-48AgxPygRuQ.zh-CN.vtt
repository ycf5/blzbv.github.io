WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.179
我们先运行一项查询 从每个客户返回第一个订单

00:00:04.179 --> 00:00:07.971
我们将直接借用上一节有关子查询的内容

00:00:07.972 --> 00:00:14.332
现在 我们使用不等式合并来合并完整表格里的网络事件

00:01:28.346 --> 00:01:34.777
这里 你能看到合并子句包括多个条件语句

00:01:34.777 --> 00:01:37.859
要运行这一查询 首先要合并客户 ID 事件

00:01:37.859 --> 00:01:41.579
与来自订单表的客户 ID 并确保匹配

00:01:41.579 --> 00:01:43.829
即便使用不等式与合并

00:01:43.829 --> 00:01:48.435
你仍然会得到某些类型的等式以确保合并正确的结果

00:01:48.435 --> 00:01:52.530
下一行将使用小于运算符添加额外的过滤器

00:01:52.530 --> 00:01:55.079
其工作方式与等号相同

00:01:55.079 --> 00:01:58.319
使用该语句评估网络事件表里的每一列

00:01:58.319 --> 00:02:02.750
经评估真实无误的列将被合并

00:02:02.750 --> 00:02:06.390
需要记住的是 使用不等式合并时 预测结果

00:02:06.390 --> 00:02:10.139
会比较困难

00:02:10.139 --> 00:02:13.044
例如 合并订单表和客户表时

00:02:13.044 --> 00:02:14.549
可以预测到 每个客户将会存在

00:02:14.550 --> 00:02:17.655
至少一个订单甚至很多订单

00:02:17.655 --> 00:02:21.110
每一张订单都对应一个客户记录

00:02:21.110 --> 00:02:24.300
但是 要搞清楚来自某个客户的第一张订单前发生了多少

00:02:24.300 --> 00:02:27.735
网络事件 就像我们现在所做的那样

00:02:27.735 --> 00:02:31.650
我们无法保证这些结果会是什么样

00:02:31.650 --> 00:02:35.974
所以 结果无法给我们提示是否得到了正确的查询结果

00:02:35.974 --> 00:02:40.489
因此 有必要再次检查你的查询逻辑以确保该逻辑能够实现你的目的


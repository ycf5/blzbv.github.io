WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.615
过滤数据使数据仅包括你需要的观察结果

00:00:03.615 --> 00:00:05.825
能够大幅提高查询速度

00:00:05.825 --> 00:00:10.070
如何执行这一操作将完全取决于你要试图解决的问题

00:00:10.070 --> 00:00:13.040
例如 如果你获得了时间序列数据

00:00:13.039 --> 00:00:19.419
限定一个小时间窗口能大大提升你的查询速度

00:00:35.310 --> 00:00:41.570
记住 你时刻都能够用数据子集进行探索性分析

00:00:41.570 --> 00:00:43.759
执行最后的查询以完善你的作品

00:00:43.759 --> 00:00:48.004
然后移除限制并在整个数据集上运行你的作品

00:00:48.005 --> 00:00:50.270
最后的查询可能会花费较长时间

00:00:50.270 --> 00:00:53.120
但至少你能够快速运行中间步骤

00:00:53.119 --> 00:00:58.359
这也是为什么大多数 SQL 编辑器自动为大多数 SQL 查询设置限制的原因

00:00:58.359 --> 00:01:00.914
他们希望对于探索性分析

00:01:00.914 --> 00:01:03.490
能够获得有限结果

00:01:03.490 --> 00:01:04.894
一旦你运行了最后查询

00:01:04.894 --> 00:01:08.810
你可以取消限制并得到全部结果

00:01:08.810 --> 00:01:14.685
需要注意的是限制与聚合的运行原理并不完全一样

00:01:14.685 --> 00:01:17.105
首先进行的是聚合

00:01:17.105 --> 00:01:21.216
然后结果被限定到具体的列数

00:01:21.216 --> 00:01:24.049
因此 如果你加总到一列

00:01:24.049 --> 00:01:37.116
但限定 10 这将无助于提高查询速度

00:01:40.376 --> 00:01:45.524
另外 如果你的结果超过 10 列

00:01:45.525 --> 00:01:49.565
只能在最后一步设置限制

00:01:49.564 --> 00:01:52.295
因此 查询最费力的部分

00:01:52.295 --> 00:01:55.004
是首先运行聚合

00:01:55.004 --> 00:01:57.539
然后 结果将被限制

00:01:57.540 --> 00:02:04.935
但这节省不了你多少时间

00:02:04.935 --> 00:02:06.659
如果你打算在运行计数前先限定数据集

00:02:06.659 --> 00:02:09.150
以便能更好的提高查询速度

00:02:09.150 --> 00:02:13.127
你需要运行子查询

00:02:25.930 --> 00:02:35.835
一般而言 使用子查询时

00:02:35.835 --> 00:02:37.950
你应该确保在数据运行的地方

00:02:37.949 --> 00:02:40.364
限制你处理的数据量

00:02:40.365 --> 00:02:43.980
以便能够最大限度地影响查询运行时间

00:02:43.979 --> 00:02:49.229
这意味着一般需要在子查询而不是外部查询中设定限制

00:02:49.229 --> 00:02:53.504
牢记一点 使用子查询将很大程度上改变你的结果

00:02:53.504 --> 00:02:57.629
因此 你应该使用子查询测试查询逻辑而不是获得实际结果

00:02:57.629 --> 00:03:00.719
正如你看到的 这一查询的结果

00:03:00.719 --> 00:03:04.000
与我们在外部查询中设定限制获得的结果非常不同


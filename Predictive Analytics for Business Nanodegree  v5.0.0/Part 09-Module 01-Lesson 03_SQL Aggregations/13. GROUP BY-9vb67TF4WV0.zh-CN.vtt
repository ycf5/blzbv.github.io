WEBVTT
Kind: captions
Language: zh-CN

00:00:00.230 --> 00:00:05.365
截至目前 我们对整个表格使用了这些聚合函数

00:00:05.365 --> 00:00:09.054
你现在了解 如何对指定表格的所有记录进行计数

00:00:09.054 --> 00:00:13.449
但你可能想对多个数据子集的记录进行计数

00:00:13.449 --> 00:00:15.719
比如说 作为一名销售经理

00:00:15.720 --> 00:00:20.810
你可能需要计算每个账户每种纸类的总销量

00:00:20.809 --> 00:00:23.339
通过 GROUP BY (分组) 你可以创建分组

00:00:23.339 --> 00:00:26.019
在聚合时相互独立

00:00:26.019 --> 00:00:29.429
也就是说 GROUP BY 可以使你只

00:00:29.429 --> 00:00:34.048
抓取单个账户的数据之和 而不是整个数据集

00:00:34.048 --> 00:00:37.229
让我们开始找寻之前提出问题的答案

00:00:37.229 --> 00:00:41.564
先对每种纸类的数量进行求和

00:00:41.564 --> 00:00:45.679
现在我们想依据账户 ID 创建各自总和的集合

00:00:45.679 --> 00:00:49.450
我们需要在 SELECT 语句中加入 account_id 列

00:00:49.450 --> 00:00:52.710
你可以看到 它返回了一个错误

00:00:52.710 --> 00:00:55.054
我们在聚合时

00:00:55.054 --> 00:00:58.195
其实是在有效地折叠 (collapse) 返回的行数

00:00:58.195 --> 00:01:00.179
在之前的查询中

00:01:00.179 --> 00:01:02.950
我们将返回结果折叠至一行

00:01:02.950 --> 00:01:04.950
我们这里之所以得到的是一个错误

00:01:04.950 --> 00:01:08.010
是因为我们这里添加了 account_id 列

00:01:08.010 --> 00:01:11.670
但是该列并没有像之前聚合的列一样进行过折叠

00:01:11.670 --> 00:01:14.790
所以此次查询不确定是要对账户 ID 进行求和

00:01:14.790 --> 00:01:17.775
还是对其进行分组

00:01:17.775 --> 00:01:21.344
我们需要对其进行说明

00:01:21.344 --> 00:01:24.484
我们要告知查询 将其整合为多个分组

00:01:24.484 --> 00:01:28.780
每个分组是该账户 ID 列中的一个值

00:01:28.780 --> 00:01:37.859
我们可以使用 GROUP BY 子句

00:01:37.859 --> 00:01:41.655
你可以直观地发现这个顺序不对 我们来修正它

00:01:41.655 --> 00:01:43.670
GROUP BY 子句永远处于

00:01:43.670 --> 00:01:49.329
WHERE 子句 (如有) 和 ORDER BY 子句之间

00:01:51.840 --> 00:01:57.534
如果 SELECT 语句中有字段没有进行聚合

00:01:57.534 --> 00:02:00.424
则应该将其放入 GROUP BY 子句

00:02:00.424 --> 00:02:02.780
如果有一列内容没有进行聚合且不在 GROUP BY 语句中

00:02:02.780 --> 00:02:06.284
则会返回错误结果 如前所示

00:02:06.284 --> 00:02:11.344
这一点很重要 也是正确使用 GROUP BY 语句的关键

00:02:11.344 --> 00:02:13.430
再次强调 没有在 SELECT 语句中进行聚合的列

00:02:13.430 --> 00:02:18.000
应该出现在 GROUP BY 语句中


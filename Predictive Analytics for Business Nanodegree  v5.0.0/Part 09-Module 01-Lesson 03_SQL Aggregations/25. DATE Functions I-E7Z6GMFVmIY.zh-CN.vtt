WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.275
到目前为止 你可能已经注意到处理日期有些困难

00:00:04.275 --> 00:00:05.970
按照 date 字段聚合

00:00:05.969 --> 00:00:08.519
实际上是不现实的

00:00:08.519 --> 00:00:10.935
每个时间戳都是独一无二的

00:00:10.935 --> 00:00:13.634
所以最现实的方法还是将其处理为最近一天

00:00:13.634 --> 00:00:16.984
一个星期或一个月 并对此期间进行聚合

00:00:16.984 --> 00:00:21.789
举个例子 按时间段计算标准纸总数量

00:00:21.789 --> 00:00:24.239
你可以看到 这里的结果

00:00:24.239 --> 00:00:27.224
并没有比原始数据更有用

00:00:27.225 --> 00:00:34.765
它只是将原始数据的 6912 行内容聚合至 6908 行

00:00:34.765 --> 00:00:38.005
表中所有数据几乎都是唯一的

00:00:38.005 --> 00:00:39.960
但是好消息是

00:00:39.960 --> 00:00:42.734
很多特殊函数可以让你更轻松地处理日期

00:00:42.734 --> 00:00:45.204
我们在深入研究日期和时间函数之前

00:00:45.204 --> 00:00:47.405
让我们来看看日期的存储方式

00:00:47.405 --> 00:00:49.020
如果你住在美国

00:00:49.020 --> 00:00:52.938
你可能已经习惯于使用 月 日 年 (MM DD YY)

00:00:52.938 --> 00:00:58.700
或类似月份在前的时间格式

00:00:58.700 --> 00:01:01.890
与世界其它标准相比 这是非常规的

00:01:01.890 --> 00:01:03.990
查看下面的讲师注释链接

00:01:03.990 --> 00:01:06.180
可以看到世界上其他大部分地方都习惯使用

00:01:06.180 --> 00:01:11.310
日 月 年 (DD MM YY) 的格式

00:01:11.310 --> 00:01:15.180
这没有好坏 只是不同而已

00:01:15.180 --> 00:01:18.520
然而数据库使用的是另一种方法

00:01:18.519 --> 00:01:21.109
按照从大到小的时间排序

00:01:21.109 --> 00:01:26.084
即 年 月 日 (YYYY MM DD)

00:01:26.084 --> 00:01:28.659
这是一个非常具体的实用工具

00:01:28.659 --> 00:01:32.859
这种日期格式 按字母排序的日期也按时间顺序排列

00:01:32.859 --> 00:01:34.700
换句话说

00:01:34.700 --> 00:01:38.225
日期排序和文本排序都是一样的

00:01:38.224 --> 00:01:40.309
这里有个例子

00:01:40.310 --> 00:01:43.650
我们可以看到 用年份在前的数据库存储日期的方式

00:01:43.650 --> 00:01:47.465
是理想的排序方式 方便我们在以后检索这些信息

00:01:47.465 --> 00:01:50.795
无论我们想要最新的还是最老的信息

00:01:50.795 --> 00:01:56.560
日在前或者月份在前的格式 没有任何意义

00:01:56.560 --> 00:02:02.969
另一个好处是可以容易地截断日期 便将其分组进行分析

00:02:02.969 --> 00:02:11.409
比如 2017-04-01 12:15:01 这个日期

00:02:11.409 --> 00:02:15.289
如果我们要将其与当天发生的其他事件进行分组

00:02:15.289 --> 00:02:17.655
以当前日期格式无法进行

00:02:17.655 --> 00:02:21.620
现在以发生在 04-01 12:15:01 的事件

00:02:21.620 --> 00:02:25.170
进行分组

00:02:25.169 --> 00:02:27.000
那对我们帮助不大


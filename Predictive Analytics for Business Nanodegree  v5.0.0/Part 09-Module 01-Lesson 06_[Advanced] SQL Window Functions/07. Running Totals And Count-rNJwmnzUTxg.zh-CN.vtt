WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.940
要应用窗口函数 最容易的地方就是仅使用计数

00:00:04.940 --> 00:00:06.975
这些函数实际上并不运行聚合

00:00:06.974 --> 00:00:10.230
ROW_NUMBER() 顾名思义

00:00:10.230 --> 00:00:14.400
是指在你定义的窗口内给定行的行数值

00:00:14.400 --> 00:00:16.425
行的编号从 1 开始

00:00:16.425 --> 00:00:20.030
按照部分窗口声明的顺序进行排列

00:00:20.030 --> 00:00:25.950
ROW_NUMBER() 并不要求在括号内定义变量

00:00:25.949 --> 00:00:32.685
这里 我们根据 ID 字段进行排序 每行增加 1

00:00:32.685 --> 00:00:38.400
因此 ID 和 row_num 字段具有相同的值

00:00:38.399 --> 00:00:40.365
但是 如果我们以 occurred_at（发生时间）排序

00:00:40.365 --> 00:00:42.158
行号就会不同

00:00:42.158 --> 00:00:46.289
而 row_num 列也因此将被赋予不同值

00:00:46.289 --> 00:00:49.679
你可以看到行号与 ID 不再匹配

00:00:49.679 --> 00:00:51.804
使用 partitioned by 子句时

00:00:51.804 --> 00:00:56.024
我们又可以在每个分区重新从 1 开始计数

00:00:56.024 --> 00:01:00.570
我们对客户 ID 进行划分 看看结果如何

00:01:00.570 --> 00:01:04.385
现在显示的是每个客户 ID 对应的行号

00:01:04.385 --> 00:01:09.710
其中第 1 行是产生的第一个订单

00:01:09.709 --> 00:01:11.884
还有另一个函数 RANK

00:01:11.885 --> 00:01:16.730
能够实现类似目的 我们来看一看

00:01:18.590 --> 00:01:21.990
尽管可能看起来相同

00:01:21.989 --> 00:01:23.769
但存在细微差别

00:01:23.769 --> 00:01:27.969
如果连续两行有相同的 occurred_at 值

00:01:27.969 --> 00:01:29.454
对它们使用 RANK 后

00:01:29.454 --> 00:01:33.280
ROW_NUMBER() 赋予这两行不同的编号

00:01:33.280 --> 00:01:38.769
如果我们按月截取(date trunc) occurred_at 字段的值 你会更清楚地了解这一点

00:01:59.480 --> 00:02:05.439
你可以看到 月份相同的记录现在被赋予相同的排序

00:02:05.439 --> 00:02:08.710
然而 排序行会跳过几个值进行弥补

00:02:08.710 --> 00:02:11.325
存在另一个类似的函数

00:02:11.324 --> 00:02:16.569
即 DENSE RANK 该函数在赋予这些行相同的排序之后 并不会跳过值

00:02:16.569 --> 00:02:20.055
因此 这一行从排序 2 跳到了排序 4 

00:02:20.056 --> 00:02:23.420
而使用 DENSE RANK 该行将直接从 2 跳到 3


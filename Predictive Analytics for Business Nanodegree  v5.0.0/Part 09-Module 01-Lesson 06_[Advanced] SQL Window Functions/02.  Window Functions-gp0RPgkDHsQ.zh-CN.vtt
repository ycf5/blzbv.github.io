WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.660
窗口函数的最实用的例子是运行总计

00:00:04.660 --> 00:00:07.304
例如 我们假设你打算统计

00:00:07.304 --> 00:00:10.349
截止目前 Parch 和 Posey 已经销售的

00:00:10.349 --> 00:00:13.419
标准纸张总量时

00:00:35.817 --> 00:00:40.500
可以看到这一查询创建了一次聚合运算

00:00:40.500 --> 00:00:44.075
即运行总计 而没有使用分组

00:00:44.075 --> 00:00:47.470
我们分解该句法并了解其工作机制

00:00:47.469 --> 00:00:52.460
本聚合的第一部分看起来非常像其他聚合

00:00:52.460 --> 00:00:55.725
加总 并被指定为 Window 函数

00:00:55.725 --> 00:00:58.170
你可以把上述聚合理解为

00:00:58.170 --> 00:01:00.690
求标准数量的总和

00:01:00.689 --> 00:01:04.980
把所有列加总到指定列

00:01:04.980 --> 00:01:08.305
以发生时间为序

00:01:08.305 --> 00:01:10.230
再比如

00:01:10.230 --> 00:01:14.469
我们想在每月初开始运行加总

00:01:14.469 --> 00:01:19.555
要收窄整个数据集到数据集内个别组的窗口

00:01:19.555 --> 00:01:35.393
你可以用 partition by 函数

00:01:35.393 --> 00:01:42.069
现在 这一查询以发生月份

00:01:42.069 --> 00:01:44.589
对交易进行分组并排序

00:01:44.590 --> 00:01:48.710
在每月内 交易以发生日期排序

00:01:48.709 --> 00:01:50.244
运行加总

00:01:50.245 --> 00:01:55.790
把之前所有标准数量列与当前列加总

00:01:55.790 --> 00:01:59.725
当你使用 partition by 这一功能进行分组时 系统会进行上述运算

00:01:59.724 --> 00:02:03.199
当你还在为排序焦头烂额时

00:02:03.200 --> 00:02:08.990
它已经对指定列进行了排序 排序方式与 order by 子句一样

00:02:08.990 --> 00:02:13.240
不同的是 它将每个分区视为独立的

00:02:13.240 --> 00:02:15.115
它也可以创建运行加总

00:02:15.115 --> 00:02:18.250
如果没有 order by 每个数值将仅仅是

00:02:18.250 --> 00:02:23.185
所有标准数量值在对应月份的总和而已

00:02:23.185 --> 00:02:25.224
为更清楚地理解

00:02:25.224 --> 00:02:30.120
这里显示的是我们不设定 order by 运行查询时的结果

00:02:34.009 --> 00:02:40.239
order 与 partition 定义了窗口内的内容

00:02:40.240 --> 00:02:45.000
运行所有这些计算时得出的经过排序的数据子集


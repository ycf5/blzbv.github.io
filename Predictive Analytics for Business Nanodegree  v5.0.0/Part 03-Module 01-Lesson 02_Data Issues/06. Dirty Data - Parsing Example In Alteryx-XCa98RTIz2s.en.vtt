WEBVTT
Kind: captions
Language: en

00:00:00.760 --> 00:00:04.570
Now we'll look at how we can
parse this data with Alteryx.

00:00:04.570 --> 00:00:07.592
In this example,
we're going to use the text input tool,

00:00:07.592 --> 00:00:10.890
which is a way to input data
without having to bring in a file.

00:00:12.330 --> 00:00:16.329
We can simply type in data,
which is commonly done when we need

00:00:16.329 --> 00:00:21.380
just a record or two to run a test or
we can paste records in from Excel or

00:00:21.380 --> 00:00:23.700
some other source,
which I'm going to do here.

00:00:25.420 --> 00:00:31.000
Next, to parse the data, we're going to
connect the text to columns tool.

00:00:31.000 --> 00:00:35.000
In the configuration window, we point
to the field that we want to parse and

00:00:35.000 --> 00:00:40.480
then set the delimiter to a period,
because as you can see

00:00:40.480 --> 00:00:43.835
the period is what is delimiting
the components of the data.

00:00:43.835 --> 00:00:48.380
Alteryx will split to
columns by default.

00:00:48.380 --> 00:00:52.330
And in the setting right here,
number of columns,

00:00:52.330 --> 00:00:56.630
you can identify how many fields
will be generated by the parsing.

00:00:56.630 --> 00:01:00.540
We need three fields, one for
the word data, one for

00:01:00.540 --> 00:01:03.360
the first number, and
one for the second number.

00:01:04.860 --> 00:01:10.190
We can set the output root name
to a specific word like col,

00:01:10.190 --> 00:01:13.560
for column, and when the data is parsed,
it will go into

00:01:13.560 --> 00:01:17.180
columns with this root name with
a consecutive number added to it.

00:01:18.240 --> 00:01:23.060
When we run Alteryx, we will see three
fields generated, with the expected data

00:01:23.060 --> 00:01:27.700
in each column, col one,
col two, and col three.

00:01:27.700 --> 00:01:30.920
In the second example,
we see we have an address field

00:01:30.920 --> 00:01:36.793
that contains the street address,
state, and zip code, all in one field.

00:01:36.793 --> 00:01:42.220
However, if we want to count the records
in each five digit zip code, it would be

00:01:42.220 --> 00:01:47.270
far easier to work with this data if the
address was in one field, the city in

00:01:47.270 --> 00:01:53.190
a second field and the state in a third
field and the zip code in a fourth.

00:01:53.190 --> 00:01:58.233
This can easily be done by parsing
the data using characters.

00:01:58.233 --> 00:02:03.090
Notice how the three components of
the address are separated by comments,

00:02:03.090 --> 00:02:07.570
the street address, the city,
and the state plus zip code.

00:02:07.570 --> 00:02:09.650
If we use the comma as a delimiter,

00:02:09.650 --> 00:02:13.140
we can divide the data into
those three components.

00:02:13.140 --> 00:02:14.490
So let's do that now.

00:02:14.490 --> 00:02:19.170
We grab the text to columns tool,
connect it up, identify

00:02:19.170 --> 00:02:24.010
the field to parse which is address and
then the comma is the delimiter.

00:02:24.010 --> 00:02:27.270
And we will split that to three columns.

00:02:28.290 --> 00:02:31.260
Address one, is the original address.

00:02:31.260 --> 00:02:33.350
Address two, is the city.

00:02:33.350 --> 00:02:37.720
And address three,
is the state and zip code.

00:02:37.720 --> 00:02:40.970
Next, we need to separate out
the state from the zip code.

00:02:41.970 --> 00:02:45.004
This can be done using
the space as the delimiter,

00:02:45.004 --> 00:02:49.350
as you can see the space is the
delimiter between these two components.

00:02:50.480 --> 00:02:54.720
However, we also want to
separate the five digit zip code

00:02:54.720 --> 00:02:56.590
from the last four digits.

00:02:56.590 --> 00:03:00.270
And you can see that a dash
is delimiting those.

00:03:00.270 --> 00:03:04.140
To parse those two components
within the Address3 field,

00:03:04.140 --> 00:03:09.480
we grab another text to columns tool,
point to the Address3 field,

00:03:09.480 --> 00:03:13.930
and set the delimiter to
be both a space and a dash.

00:03:15.040 --> 00:03:19.250
There are three columns that
we would like to split into.

00:03:19.250 --> 00:03:22.195
And they will all start with ADDR.

00:03:24.160 --> 00:03:28.120
As a result we can see that
the Address3 field has been split

00:03:28.120 --> 00:03:30.790
into its three component parts.

00:03:30.790 --> 00:03:35.640
And now we can clean up the dataset
to get rid of fields and rename them.

00:03:35.640 --> 00:03:40.270
Grab the Select tool, remove
the fields that we no longer need,

00:03:40.270 --> 00:03:44.665
like address and address 3 and
rename the existing fields.

00:03:44.665 --> 00:03:48.336
Address, City,

00:03:48.336 --> 00:03:52.994
State, ZIP, ZIP4.

00:03:52.994 --> 00:03:59.445
[SOUND] The result is the newly
parsed data with the fixed up fields.

